{
  "name": "mbedcrypto",
  "tagline": "a portable, small, easy to use and fast c++11/14 library for cryptography.",
  "body": "# mbedcrypto\r\n`mbedcrypto` is a portable, small, easy to use, feature rich and fast\r\n`c++11/14` library for cryptography based on fantastic and clean\r\n[mbedtls](https://github.com/ARMmbed/mbedtls)<sup>[note](#mbedtls)</sup>\r\n<sup>[note](#cryptography)</sup>.\r\n\r\na sister project for `Qt5` developers is available as\r\n[qpolarssl](https://github.com/azadkuh/qpolarssl), also `mbedcrypto` is newer\r\nand has more features with smaller footprint.\r\n\r\n\r\n\r\n## features and highlights\r\n\r\n- *small size*: the `mbedcrypto` is less than `250KB` in size (stripped under Linux and\r\n OS X) with all *predefined* algorithms. it can be easily embedded into\r\n your service or application.\r\n- *easy to use*: although cryptography<sup>[note](#cryptography)</sup> is\r\n complex and complicated, `mbedcrypto` hides most of the complexities, tries to\r\n be easy to use and hard to misuse. see [samples](#usage)\r\n- *portable*: needs an standard `c++11/14` compiler and compliant `stl`,\r\n compiled and tested by:\r\n  - `gcc 5.x+` under `linux`\r\n  - `clang 3.6+` under `os x`\r\n  - `msvc 2015` community edition under `windows 7`\r\n- *low dependency*:\r\n  - the `mbedtls`<sup>[note](#mbedtls)</sup> as underlying cryptography engine,\r\n   is the only mandatory dependency.\r\n  - [catch](https://github.com/philsquared/Catch): only for unit testing.\r\n  - `cmake` for building the library and the unit test app.\r\n- *high+low level*: both high level (c++ objects / exception) and low level (c\r\n pointer / error code) functions are available. see [samples](#usage)\r\n- *highly configurable*: to add or remove the algorithms, simply change `cmake`\r\n build options. see [build options](#build-options)\r\n\r\n\r\n## supported algorithms\r\nfollowing algorithms are included in `mbedcrypto` in *default build* (see\r\n [samples](#usage)):\r\n\r\n- **binary/text conversions**: see [samples](#text-binary-conversion)\r\n  - `hex`\r\n  - `base64`\r\n\r\n- **hashes (message digest)**: see [samples](#hashes)\r\n  - `md5`\r\n  - `sha1`\r\n  - `sha224` / `sha256`\r\n  - `sha384` / `sha512`\r\n  - `hmac`\r\n  - optional hashes: `ripemd160`, `md4`, `md2` (deprecated)\r\n\r\n- **ciphers (symmetric)**: see [samples](#ciphers)\r\n  - `aes` (128, 192, 256 bits) and `aes-ni` (hardware accelerated)\r\n  - `des` and `3des` (triple-des)\r\n  - optional ciphers: `blowfish`, `camellia` and `arc4`\r\n\r\n- **cipher block modes**:\r\n  - `ecb` electronic codebook\r\n  - `cbc` cipher block chaining\r\n  - `ctr` counter mode\r\n  - `gcm` Galois/counter and `ccm` (counter cbc-mac) modes.\r\n   see [authneticated encryption with additional data\r\n   (AEAD)](https://en.wikipedia.org/wiki/Authenticated_encryption)\r\n  - optional block modes: `cfb`, `stream` (for `arc4`)\r\n\r\n- **paddings**:\r\n  - `pkcs7`\r\n  - *one and zeros*\r\n  - *zeros and length*\r\n  - *zeros*\r\n\r\n- **random byte generator**: see [samples](#random-byte-generator)\r\n  - `ctr_drbg` counter mode deterministic random byte generator based on\r\n   `aes-256` [NIST SP 800-90](https://en.wikipedia.org/wiki/NIST_SP_800-90A)\r\n\r\n- **pki (asymmetric)**: public key infrastructure, see [samples](#pks)\r\n  - `rsa`\r\n  - `pem` and `der` key formats (ASN.1)\r\n  - optional pks: `eckey` elliptic curve, `eckey_dh` elliptic key\r\n   Diffie–Hellman, `ecdsa` elliptic key digital signature algorithm, `rsa_alt`\r\n   and `rsassa_pss` RSA standard signature algorithm, probabilistic signature\r\n   scheme\r\n  - optional `rsa` key generator\r\n  - optional `ec curves` from well known domain parameters as `NIST`, `Kolbitz`,\r\n  `brainpool` and `Curve25519`.\r\n\r\ntotal number of supported algorithms:\r\n\r\n- hashes: 9\r\n- paddings: 5\r\n- ciphers: 47\r\n- pki: 6\r\n\r\nsee [types.hpp](./include/mbedcrypto/types.hpp)\r\n\r\n\r\n## setup\r\nafter cloning this repository, first update the dependencies:\r\n```bash\r\n# on mbedcrypto directory\r\n$medcrypto/> ./update-dependencies.sh\r\n```\r\nthis script automatically setups `3rdparty` directory, then tries to pull or\r\nupdate dependencies from github.\r\n\r\n### Unices\r\nunder Linux, OS X:\r\n```bash\r\n$medcrypto/> mkdir build\r\n$medcrypto/> cd build\r\n\r\n$build/> cmake ..\r\n$build/> make\r\n```\r\n\r\n> the `mbedcrypto` library and the companion unit test app would be built on\r\n> `xbin` directory.\r\n\r\n### Windows\r\nunder Windows (MSVC) probably:\r\n```bash\r\n$medcrypto/> mkdir build\r\n$medcrypto/> cd build\r\n\r\n$build/> cmake ..\r\n$build/> cmake --build . --config Release\r\n```\r\n\r\n\r\n### doxygen\r\nunder **Unices** if you have already installed `doxygen`:\r\n```bash\r\n# builds api documents into ./docs\r\n$build> make docs\r\n# removes ./docs\r\n$build> make clean_docs\r\n```\r\n\r\n---\r\n\r\n## build options\r\nthese are the most important build options:\r\n\r\n| options          | default | message                                                         |\r\n| :---             | :---:   | :---                                                            |\r\n| BUILD_MD2        | OFF     | enable md2 hash (unsecure and deprecated)                       |\r\n| BUILD_MD4        | OFF     | enable md4 hash                                                 |\r\n| BUILD_RIPEMD160  | OFF     | enable ripemd160 hash                                           |\r\n| BUILD_CFB        | OFF     | enable cfb (cipher feedback mode)                               |\r\n| BUILD_CTR        | ON      | enable ctr (cipher counter mode)                                |\r\n| BUILD_GCM        | ON      | enable gcm (Galois cipher mode, for aead cryptography)          |\r\n| BUILD_CCM        | ON      | enable ccm (counter cbc-mac cipher mode, for aead cryptography) |\r\n| BUILD_DES        | ON      | enable des and triple-des cipher                                |\r\n| BUILD_BLOWFISH   | OFF     | enable blowfish cipher                                          |\r\n| BUILD_CAMELLIA   | OFF     | enable camellia cipher                                          |\r\n| BUILD_ARC4       | OFF     | enable arc4 cipher (unsecure)                                   |\r\n| BUILD_PK_EXPORT  | ON      | enable export keys in pem or der format                         |\r\n| BUILD_RSA_KEYGEN | ON      | enable rsa key generator                                        |\r\n| BUILD_EC         | OFF     | enable eckey, eckey_dh and ecdsa algorithms                     |\r\n\r\nplease see [CMakeLists.txt](./CMakeLists.txt) for the full list.\r\n\r\nto add or remove algorithms or features:\r\n```bash\r\n# cmake, ccmake or cmake-gui\r\n$build/> cmake .. -DBUILD_CAMELLIA=ON -DBUILD_PK_EXPORT=ON -DBUILD_RSA_KEYGEN=ON\r\n\r\n# or optionally\r\n$build/> ccmake .\r\n\r\n# to disable making of the test app:\r\n$build/> cmake .. -DBUILD_TESTS=OFF\r\n```\r\n\r\noptionally if you use `gcc` or `clang`, you can also build `mbedcrypto` as a\r\nshared library as:\r\n```bash\r\n$build/> cmake .. -DBUILD_SHARED_LIBS=ON\r\n$build/> make\r\n```\r\n\r\n---\r\n\r\n## usage\r\n\r\n### buffer_t\r\n`buffer_t` (synonym for `std::string`)\r\n```cpp\r\nnamespace mbedcrypto {\r\n  using buffer_t = std::string;\r\n}\r\n```\r\nis widely used in `mbedcrypto` api as main data container for input / output\r\nmethods.\r\n\r\ncurrent `std::string` implementations are known to be *contiguous*, so I prefer\r\n`std::string` over `std::vector<unsigned char>` because it helps users to\r\neasily feed both text and binary buffers into `mbedtls` api without any cast or\r\nconversion.\r\n\r\nsee [configs.hpp](./include/mbedcrypto/configs.hpp)\r\n\r\n\r\n### error handling\r\n`mbedcrypto` objects and functions throw\r\n[`mbedcrypro::exception`](./include/mbedcrypto/exception.hpp) unless they're\r\ntagged by `noexcept` keyword.\r\n```cpp\r\ntry {\r\n  //\r\n  // mbedcrypto codes ...\r\n  //\r\n} catch ( mbedcrypto::exception& cerr ) {\r\n  std::cerr << \"the expanded error message is: \"\r\n      << cerr.what() << std::endl;\r\n  int c_error_code = cerr.code(); // the underlying error code\r\n}\r\n```\r\n\r\nthe structure of `cerr.what()`:\r\n```text\r\n[message, prefix or function name][(error code in hex): [module name] error string]\r\n\r\nex:\r\nmbedtls_md_starts(-0x5100): MD - Bad input parameters to function\r\n - function name: mbedtls_md_starts\r\n - error code: -0x5100\r\n - module name: MD (message digest)\r\n```\r\n\r\nthe low level functions returns a non-zero `int` as an error and are tagged by\r\n`noexcept`:\r\n```cpp\r\nint ret = an_object.a_low_level_method(...);\r\nif ( ret != 0 ) {\r\n  std::cout << \"underlying error code: \"\r\n      << mbedcrypto::mbedtls_error_string(ret) << std::endl;\r\n}\r\n```\r\n\r\n### available algorithms\r\nto list all available (included in build) algorithms:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nauto hashes = installed_hashes(); // returns std::vector<mbedcrypto::hasht_t>\r\nstd::cout << \"supports \" << hashes.size() << \" hash algorithms: \";\r\nfor ( auto h : hashes ) { // print all installed hashes\r\n  // convert type to string\r\n  std::cout << to_string(h) << \" , \";\r\n}\r\n\r\n// similarly\r\nauto paddings = installed_paddings();\r\nauto bmodes   = installed_block_modes();\r\nauto ciphers  = installed_ciphers();\r\nauto pks      = installed_pks();\r\nauto curves   = installed_curves();\r\n\r\n// convert from string to a type\r\nauto htype = from_string<hash_t>(\"sha256\");\r\nif ( htype != hash_t::none ) {\r\n}\r\n```\r\n\r\nto check for availability of a feature:\r\n```cpp\r\n// check by type (enum class)\r\nif ( supports(cipher_t::aes_256_cbc)   &&   supports(pk_t::rsa) ) {\r\n  // do stuff\r\n}\r\n// check by algorithm name\r\nif ( supports_hash(\"sha1\")    &&    supports_pk(\"rsa\") ) {\r\n  // sign a message ...\r\n}\r\n// both upper and lower case are supported\r\nif ( supports_cipher(\"CAMELLIA_128_CBC\") ) {\r\n}\r\n\r\n// to check a single feature\r\nif ( suppurts(features::aes_ni) ) {\r\n  std::cout << \"this system supports AESNI (hardware accelerated AES)\" << std::endl;\r\n}\r\n\r\nif ( supports(features::aead)    &&    supports(cipher_bm::gcm) ) {\r\n  // do GCM authenticated encryption with additional data\r\n}\r\n```\r\n\r\nsee [types.hpp](./include/mbedcrypto/types.hpp)\r\n\r\n\r\n### text-binary conversion\r\nhandy utility to convert binary into (or from) text:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nstd::fstream fpng = open_a_png_file(...);\r\nstd::string bin_data; // binary data\r\nfpng >> bin_data;\r\n\r\nauto png_hex = to_hex(bin_data);\r\nauto png_b64 = to_base64(bin_data);\r\n\r\nREQUIRE( from_hex(png_hex) == from_base64(png_b64) );\r\n\r\n// to get the required base64 size\r\nsize_t encode_size = base64::encode_size(bin_data);\r\npng_b64 = base64::encode(bin_data);\r\n\r\nREQUIRE( base64::decode_size(png_b64) == bin_data.size() );\r\n\r\nREQUIRE_THROWS( base64::decode(\"invalid base64 string @#$%#^$\") );\r\n```\r\n\r\nsee [tcodec.hpp](./include/mbedcrypto/tcodec.hpp)\r\n\r\n\r\n### hashes\r\n(cryptographic hashes also known as message digests)\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\n// by single shot functions\r\nauto hash_value = make_hash(hash_t::sha256, source_data);\r\nauto hmac_value = hmac::make(hash_t::sha1, key_data, source_data);\r\n\r\nstd::cout << to_base64(hash_value) << std::endl;\r\n```\r\nor\r\n```cpp\r\nhash h0(hash_t::ripemd160);\r\nhash h1(from_string<hash_t>(\"sha1\"));\r\n\r\nh1.start();\r\nwhile ( ... ) {\r\n  h1.update(read_some_data());\r\n}\r\nauto hash_value = h1.finish();\r\n\r\n// re-use\r\nh1.start();\r\nh1.update(...); // single or multiple updates\r\nhash_value = h1.finish();\r\n```\r\n\r\nsee [hash.hpp](./include/mbedcrypto/hash.hpp)\r\n\r\n\r\n### ciphers\r\nIf a cipher block mode allows, the `cipher` class automatically breaks input\r\ndata into **chunks** (`cipher::block_size()`) and frees the user from\r\nbreaking/merging of input/output data:\r\n\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nstd::string source_plain_data = read_from_somewhere();\r\n\r\n// encrypt and decrypt by single-shot functions\r\nauto ciphered_buffer = cipher::encrypt(\r\n    cipher_t::aes_256_cbc,\r\n    padding_t::pkcs7,\r\n    initial_vector_data,  // get iv size from cipher::iv_size()\r\n    key_data,             // get key length in bit by cipher::key_bitlen()\r\n    source_plain_data     // could be in any size because of cbc block mode\r\n    );\r\n\r\nauto decrypted_buffer = cipher::decrypt(\r\n    cipher_t::aes_256_cbc,\r\n    padding_t::pkcs7,\r\n    initial_vector_data,\r\n    key_data,\r\n    ciphered_buffer\r\n    );\r\n\r\nREQUIRE( source_plain_data == decrypted_buffer );\r\n```\r\n\r\nto use [authenticated encryption with associated data (aka\r\naead)](https://en.wikipedia.org/wiki/Authenticated_encryption):\r\n```cpp\r\nstd::string the_additional_data = ...;\r\n\r\nauto encr = cipher::encrypt_aead(\r\n    cipher_t::aes_256_ccm,\r\n    iv_data,\r\n    key_data,\r\n    the_additional_data,\r\n    source_plain_data\r\n    );  ///< returns a std::tuple< computed_tag, encrypted_data >\r\n\r\n\r\nauto decr = cipher::decrypt_aead(\r\n    cipher_t::aes_256_ccm,\r\n    iv_data,\r\n    key_data,\r\n    the_additional_data,\r\n    encr\r\n    );  ///< returns a std::tuple< authentication_status, decrypted_data >\r\n\r\n\r\n  REQUIRE( std::get<0>(decr) == true ); // authenticated?\r\n  REQUIRE( std::get<1>(decr) == source_plain_data );\r\n```\r\n\r\n\r\nor by reusable object:\r\n```cpp\r\n// construct and setup properties\r\ncipher cipdec(cipher_t::aes_256_cbc);\r\ncipdec\r\n  .padding(padding_t::pkcs7)\r\n  .iv(iv_data)\r\n  .key(key_data, cipher::decrypt_mode);\r\n\r\n// by start() / update()s / finish()\r\ncipdec.start();\r\nstd::string decrypted_data;\r\nwhile ( ... ) {\r\n  decrypted_data += cipdec.update(read_some_encrypted_data());\r\n}\r\ndecrypted_data += cipdec.finish();\r\nREQUIRE( source_plain_data == decrypted_data );\r\n\r\n// re-use the object\r\ncipdec.start();\r\ncipdec.update(...); // or multiple updates\r\ncipdec.finish();\r\n\r\n// single shot re-use\r\ndecrypted_data = cipdec.crypt(encrypted_data);\r\n```\r\n\r\nsee [cipher.hpp](./include/mbedcrypto/cipher.hpp)\r\n\r\n\r\n### random byte generator\r\nto make cryptographically secure psuedo random bytes:\r\n\r\n```cpp\r\nrnd_generator rgen;\r\nauto random_data1 = rgen.make(256); // in bytes\r\n// entropy and ctr_drbg are not so cheap, reuse them:\r\nauto random_data2 = rgen.make(32);  // in bytes\r\n\r\n// update internal state with custom data (may helps entropy)\r\nrgen.update(some_random_volatile_data);\r\nauto nonce = rgen.make(64);\r\n```\r\n\r\nsee [rnd_generator.hpp](./include/mbedcrypto/rnd_generator.hpp)\r\n\r\n\r\n### pks\r\nplaying with `rsa` keys:\r\n\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nrsa pri_key;\r\n// import from data buffer\r\npri_key.import_key(private_key_data, optional_password);\r\n// or load from a file by file-name\r\npri_key.load_key(\"private_key.pem\");\r\n\r\nrsa pub_key;\r\npub_key.import_public_key(public_key_data);\r\n\r\n// [optional] check matching public/private pair\r\nREQUIRE( check_pair(pub_key, pri_key) == true );\r\n\r\n// export keys\r\nif ( supports(features::pk_export) ) {\r\n    auto der_data = pub_key.export_public_key(pk::der_format);\r\n    // write or share\r\n}\r\n\r\n// key generation\r\nif ( supports(features::rsa_keygen) ) {\r\n    rsa pri_key;\r\n    pri_key.generate_key(2048); // a 2048bit key\r\n    // do stuff\r\n}\r\n\r\nauto af = pub_key.what_can_do(); // what can i do with this key?\r\n// returns pk::action_flags (key capabilities) with following data:\r\n// af.encrypt = true\r\n// af.decrypt = false\r\n// af.sign    = false\r\n// af.verify  = true\r\n// because pub_key is a valid rsa public-key\r\n\r\nauto kinfo = pri_key.key_info();\r\n// kinfo.N  :  public modulus\r\n// kinfo.E  :  public exponent\r\n// only valid if the key is a private key\r\n// kinfo.D  :  private exponent\r\n// kinfo.P  :  1st prime factor\r\n// kinfo.Q  :  2nd prime factor\r\n// kinfo.DP  : D % (P - 1)\r\n// kinfo.DQ  : D % (Q - 1)\r\n// kinfo.QP  : 1 / (Q % P)\r\n```\r\n\r\nto sign and verify by `rsa`:\r\n```cpp\r\n// signature & verification\r\nstd::string message = read_message_from_somewhere();\r\nauto signature      = pri_key.sign(message, hash_t::sha256);\r\nREQUIRE( pub_key.verify(signature, message, hash_t::sha256);\r\n```\r\n\r\nto encrypt and decrypt by `rsa`:\r\n```cpp\r\nconst auto hvalue = hash::make(hash_t::sha256, message);\r\n\r\nauto encv = pub_key.encrypt(hvalue);\r\nauto decv = pri_key.decrypt(encv);\r\nREQUIRE( decv == hvalue );\r\n\r\n// or\r\nauto encv = pub_key.encrypt(message, hash_t::sha256);\r\nauto decv = pri_key.decrypt(encv);\r\nREQUIRE( decv == hash::make(hash_t::sha256, message) );\r\n\r\n```\r\n\r\nsee [rsa.hpp](./include/mbedcrypto/rsa.hpp)\r\n\r\n\r\nto create `ec` keys from curves:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nif ( supports(features::pk_export)  &&  supports(pk_t::eckey) ) {\r\n    ecp gen; // elliptic curve public key infrastructure\r\n    gen.generate_key(curve_t::secp224k1); // or any other supported curves\r\n    auto pri_data = gen.export_key(pk::pem_format);\r\n    auto pub_data = gen.export_public_key(pk::pem_format);\r\n    // do stuff\r\n\r\n    auto kinfo = gen.key_info(); // ecurve points and secret\r\n    std::cout\r\n        << \"\\nQx (\" << kinfo.Qx.bitlen() << \"): \" << kinfo.Qx.to_string()\r\n        << \"\\nQy (\" << kinfo.Qy.bitlen() << \"): \" << kinfo.Qy.to_string()\r\n        << \"\\nQz (\" << kinfo.Qz.bitlen() << \"): \" << kinfo.Qz.to_string()\r\n        << \"\\nd  (\" << kinfo.D.bitlen()  << \"): \" << kinfo.d.to_string()\r\n        << std::endl;\r\n}\r\n```\r\n\r\nto sign and verify by `ecdsa`:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nif ( supports(pk_t::ecdsa)  &&  supports(features::ec_keygen) ) {\r\n    ecdsa pri_key; // both pk_t::eckey and pk_t::ecdsa works\r\n    pri_key.generate_key(curve_t::secp192k1);\r\n    auto sig = pri_key.sign(message, hash_t::sha384);\r\n\r\n    ecdsa pub_key;\r\n    pub_key.import_public_key(\r\n            pri_key.export_public_key(pk::pem_format)\r\n            );\r\n\r\n    REQUIRE( pub_key.verify(sig, message, hash_t::sha384) );\r\n}\r\n```\r\n\r\nto create a shared secret by `ECDH(E)` when both ends know the curve type:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n// const auto ctype = curve_t::secp224r1 // both know the curve type\r\n\r\necdh server;\r\nauto srv_pub = server.make_peer_key(ctype);\r\n// send srv_pub to client\r\n\r\necdh client;\r\nclient.generate_key(ctype); // alternative approach to make_peer_key()\r\nauto cli_pub = client.peer_key();\r\n// send cli_pub to server\r\n\r\nauto sss = server.shared_secret(cli_pub); // on server\r\nauto css = client.shared_secret(srv_pub); // on client\r\n\r\nREQUIRE( (sss == css) );\r\n```\r\n\r\nor if the curve parameters are defined by server at runtime as defined in\r\n[RFC 4492: Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer\r\nSecurity (TLS)](https://tools.ietf.org/html/rfc4492) do:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\necdh server;\r\n// (only) server defines the curve type\r\nauto skex = server.make_server_key_exchange(curve_t::secp192k1);\r\n// send server's key exchange params to client\r\n\r\necdh client;\r\nauto cli_pub = client.make_client_peer_key(skex);\r\nauto css     = client.shared_secret();\r\n// send cli_pub to server\r\n\r\nauto sss     = server.shared_secret(cli_pub); // on server\r\n\r\nREQUIRE( (sss == css) );\r\n```\r\n\r\nsee [ecp.hpp](./include/mbedcrypto/ecp.hpp)\r\n\r\n---\r\n\r\n## tests\r\nsamples and unit tests are available under [tests/tdd](./tests/tdd/) folder.\r\n\r\nthe test application has been built by\r\n[catch](https://github.com/philsquared/Catch):\r\n```bash\r\n# to list all available test tags:\r\n$xbin/> ./tests -t\r\n\r\n# run the tests\r\n$xbin/> ./tests\r\n```\r\n\r\npossible output:\r\n```text\r\nsupports 6 hash algorithms: MD5 , SHA1 , SHA224 , SHA256 , SHA384 , SHA512 ,\r\nsupports 5 padding algorithms: PKCS7 , ONE_AND_ZEROS , ZEROS_AND_LEN , ZEROS ,\r\n         NONE ,\r\nsupports 6 block modes: NONE , ECB , CBC , CTR , GCM , CCM ,\r\nsupports 21 cipher algorithms: AES-128-ECB , AES-192-ECB , AES-256-ECB ,\r\n         AES-128-CBC , AES-192-CBC , AES-256-CBC , AES-128-CTR , AES-192-CTR ,\r\n         AES-256-CTR , AES-128-GCM , AES-192-GCM , AES-256-GCM , DES-ECB ,\r\n         DES-CBC , DES-EDE-ECB , DES-EDE-CBC , DES-EDE3-ECB , DES-EDE3-CBC ,\r\n         AES-128-CCM , AES-192-CCM , AES-256-CCM ,\r\n this system supports AESNI (hardware accelerated AES)\r\n this build supports AEAD (authenticated encryption with additional data)\r\nsupports 4 pk (public key) algorithms: RSA , EC , EC_DH , ECDSA ,\r\n this build supports PK export (*.pem, *.der) facility\r\n this build supports RSA key generation\r\n this build supports EC (elliptic curve) key generation\r\nsupports 12 elliptic curves: SECP192R1 , SECP224R1 , SECP256R1 , SECP384R1 ,\r\n         SECP521R1 , SECP192K1 , SECP224K1 , SECP256K1 , BP256R1 , BP384R1 ,\r\n         BP512R1 , CURVE25519 ,\r\n\r\n===============================================================================\r\nAll tests passed (952 assertions in 17 test cases)\r\n\r\n```\r\n---\r\n\r\n## notes\r\n\r\n### cryptography\r\n[cryptography](https://en.wikipedia.org/wiki/Outline_of_cryptography) is both\r\ncomplex and complicated, it requires a vast knowledge of mathematics, concepts,\r\nprinciples, algorithms, standards, conventions, continuous investigation of\r\nattacks, ...\r\n\r\n> As cryptography is mostly used to protect sensitive data, writing a library\r\n> for it is a daunting task and difficult by any factor.\r\n\r\nSo instead of writing a library from scratch, `mbedcrypto` stands on the\r\nshoulders of giants, `mbedtls` is this case.\r\n\r\n### mbedtls\r\nAlthough [mbedtls](https://github.com/ARMmbed/mbedtls) is mostly a `TLS/SSL`\r\nlibrary for embedded devices, it has already implemented the most famous and\r\nwidely used cryptographic algorithms and actively developed and maintained.\r\n\r\nArguably `mbedtls` has cleaner code than `openssl`, it's easier to read, use\r\nand maintain, and it has been designed for efficiency and portability from\r\nscratch (for embedded devices), and has many advantages over `openssl` like as\r\nreadability, size, compiling and setup, … to name a few.\r\n\r\n\r\n## disclaimer\r\n\r\n- implementing an easy-to-use, lightweight and portable `c++` library for\r\ncryptography are the main purpose of `mbedcrypto`.\r\n- there are many more algorithms in cryptographic libraries, the focus of\r\n`mbedcrypto` is on the most important or widely used algorithms, tries to be\r\nsimple and not to bloat your application.\r\n- as mentioned in [notes](#notes), the cryptography can be divided into several\r\nareas of study and best practices, I'm not a guru nor a specialist in this\r\nfield.\r\n\r\n\r\n> If you have any ideas, critiques, suggestions or whatever you want to call\r\n> it, please open an issue. I'll be happy to hear from you what you'd see in\r\n> this lib. I think about all suggestions, and I try to add those that make\r\n> sense.\r\n\r\n\r\n## license\r\nDistributed under the MIT license. Copyright (c) 2016, Amir Zamani.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}