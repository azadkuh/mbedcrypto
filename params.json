{
  "name": "mbedcrypto",
  "tagline": "a portable, small, easy to use and fast c++11/14 library for cryptography.",
  "body": "# mbedcrypto\r\n`mbedcrypto` is a portable, small, easy to use, feature rich and fast\r\n`c++11/14` library for cryptography based on fantastic and clean\r\n[mbedtls](https://github.com/ARMmbed/mbedtls)<sup>[note](#mbedtls)</sup>\r\n<sup>[note](#cryptography)</sup>.\r\n\r\na sister project for `Qt5` developers is available as\r\n[qpolarssl](https://github.com/azadkuh/qpolarssl), also `mbedcrypto` is newer\r\nand has more features with smaller footprint.\r\n\r\n\r\n\r\n## features and highlights\r\n\r\n- *small size*: the `mbedcrypto` is less than `250KB` in size (under Linux and\r\n OS X) with all *predefined* algorithms. it can be easily embedded into\r\n your service or application.\r\n- *easy to use*: although cryptography<sup>[note](#cryptography)</sup> is\r\n complex and complicated, `mbedcrypto` hides most of the complexities, tries to\r\n be easy to use and hard to misuse. see [samples](#usage)\r\n- *portable*: needs an standard `c++11/14` compiler and compliant `stl`,\r\n compiled and tested by:\r\n  - `gcc 5.x` under `linux`\r\n  - `clang` under `os x`\r\n  - `msvc 2015` community edition under `windows 7`\r\n- *low dependency*:\r\n  - the `mbedtls`<sup>[note](#mbedtls)</sup> as underlying cryptography engine,\r\n   is the only mandatory dependency.\r\n  - [catch](https://github.com/philsquared/Catch): only for unit testing.\r\n  - `cmake` for building the library and the unit test app.\r\n- *high+low level*: both high level (c++ objects / exception) and low level (c\r\n pointer / error code) functions are available. see [samples](#usage)\r\n- *highly configurable*: to add or remove the algorithms, simply change `cmake`\r\n build options. see [build options](#build-options)\r\n\r\n\r\n## supported algorithms\r\nfollowing algorithms are included in `mbedcrypto` in *default build* (see\r\n [samples](#usage)):\r\n\r\n- **binary/text conversions**: see [samples](#text-binary-conversion)\r\n  - `hex`\r\n  - `base64`\r\n\r\n- **hashes (message digest)**: see [samples](#hashes)\r\n  - `md5`\r\n  - `sha1`\r\n  - `sha224` / `sha256`\r\n  - `sha384` / `sha512`\r\n  - `hmac`\r\n  - optional hashes: `ripemd160`, `md4`, `md2` (deprecated)\r\n\r\n- **ciphers (symmetric)**: see [samples](#ciphers)\r\n  - `aes` (128, 192, 256 bits) and `aes-ni` (hardware accelerated)\r\n  - `des` and `3des` (triple-des)\r\n  - optional ciphers: `blowfish`, `camellia` and `arc4`\r\n\r\n- **cipher block modes**:\r\n  - `ecb` electronic codebook\r\n  - `cbc` cipher block chaining\r\n  - `ctr` counter mode\r\n  - `gcm` Galois/counter and `ccm` (counter cbc-mac) modes.\r\n   see [authneticated encryption with additional data\r\n   (AEAD)](https://en.wikipedia.org/wiki/Authenticated_encryption)\r\n  - optional block modes: `cfb`, `stream` (for `arc4`)\r\n\r\n- **paddings**:\r\n  - `pkcs7`\r\n  - *one and zeros*\r\n  - *zeros and length*\r\n  - *zeros*\r\n\r\n- **random byte generator**: see [samples](#random-byte-generator)\r\n  - `ctr_drbg` counter mode deterministic random byte generator based on\r\n   `aes-256` [NIST SP 800-90](https://en.wikipedia.org/wiki/NIST_SP_800-90A)\r\n\r\n- **pki (asymmetric)**: public key infrastructure, see [samples](#pks)\r\n  - `rsa`\r\n  - `pem` and `der` key formats (ASN.1)\r\n  - optional pks: `eckey` elliptic curve, `eckey_dh` elliptic key\r\n   Diffie–Hellman, `ecdsa` elliptic key digital signature algorithm, `rsa_alt`\r\n   and `rsassa_pss` RSA standard signature algorithm, probabilistic signature\r\n   scheme\r\n  - optional `rsa` key generator\r\n\r\ntotal number of supported algorithms:\r\n\r\n- hashes: 9\r\n- paddings: 5\r\n- ciphers: 47\r\n- pki: 6\r\n\r\nsee [types.hpp](./include/mbedcrypto/types.hpp)\r\n\r\n\r\n## setup\r\nafter cloning this repository, first update the dependencies:\r\n```bash\r\n# on mbedcrypto directory\r\n$medcrypto/> ./update-dependencies.sh\r\n```\r\nthis script automatically setups `3rdparty` directory, then tries to pull or\r\nupdate dependencies from github.\r\n\r\n### Unices\r\nunder Linux, OS X:\r\n```bash\r\n$medcrypto/> mkdir build\r\n$medcrypto/> cd build\r\n\r\n$build/> cmake ..\r\n$build/> make\r\n```\r\n\r\n> the `mbedcrypto` library and the companion unit test app would be built on\r\n> `xbin` directory.\r\n\r\n### Windows\r\nunder Windows (MSVC) probably:\r\n```bash\r\n$medcrypto/> mkdir build\r\n$medcrypto/> cd build\r\n\r\n$build/> cmake ..\r\n$build/> cmake --build . --config Release\r\n```\r\n\r\n\r\n### doxygen\r\nunder **Unices** if you have already installed `doxygen`:\r\n```bash\r\n# builds api documents into ./docs\r\n$build> make docs\r\n# removes ./docs\r\n$build> make clean_docs\r\n```\r\n\r\n---\r\n\r\n## build options\r\nthese are the most important build options:\r\n\r\n| options          | default | message                                                         |\r\n| :---             | :---:   | :---                                                            |\r\n| BUILD_MD2        | OFF     | enable md2 hash (unsecure and deprecated)                       |\r\n| BUILD_MD4        | OFF     | enable md4 hash                                                 |\r\n| BUILD_RIPEMD160  | OFF     | enable ripemd160 hash                                           |\r\n| BUILD_CFB        | OFF     | enable cfb (cipher feedback mode)                               |\r\n| BUILD_CTR        | ON      | enable ctr (cipher counter mode)                                |\r\n| BUILD_GCM        | ON      | enable gcm (Galois cipher mode, for aead cryptography)          |\r\n| BUILD_CCM        | ON      | enable ccm (counter cbc-mac cipher mode, for aead cryptography) |\r\n| BUILD_DES        | ON      | enable des and triple-des cipher                                |\r\n| BUILD_BLOWFISH   | OFF     | enable blowfish cipher                                          |\r\n| BUILD_CAMELLIA   | OFF     | enable camellia cipher                                          |\r\n| BUILD_ARC4       | OFF     | enable arc4 cipher (unsecure)                                   |\r\n| BUILD_PK_EXPORT  | ON      | enable export keys in pem or der format                         |\r\n| BUILD_RSA_KEYGEN | ON      | enable rsa key generator                                        |\r\n| BUILD_EC         | OFF     | enable eckey and eckey_dh public key algorithms                 |\r\n| BUILD_ECDSA      | OFF     | enable ecdsa algorithms                                         |\r\n\r\nplease see [CMakeLists.txt](./CMakeLists.txt) for the full list.\r\n\r\nto add or remove algorithms or features:\r\n```bash\r\n# cmake, ccmake or cmake-gui\r\n$build/> cmake .. -DBUILD_CAMELLIA=ON -DBUILD_PK_EXPORT=ON -DBUILD_RSA_KEYGEN=ON\r\n\r\n# or optionally\r\n$build/> ccmake .\r\n\r\n# to disable making of the test app:\r\n$build/> cmake .. -DBUILD_TESTS=OFF\r\n```\r\n\r\noptionally if you use `gcc` or `clang`, you can also build `mbedcrypto` as a\r\nshared library as:\r\n```bash\r\n$build/> cmake .. -DBUILD_SHARED_LIBS=ON\r\n$build/> make\r\n```\r\n\r\n---\r\n\r\n## usage\r\n\r\n### buffer_t\r\n`buffer_t` (synonym for `std::string`)\r\n```cpp\r\nnamespace mbedcrypto {\r\n  using buffer_t = std::string;\r\n}\r\n```\r\nis widely used in `mbedcrypto` api as main data container for input / output\r\nmethods.\r\n\r\ncurrent `std::string` implementations are known to be contiguous, so I prefer\r\n`std::string` over `std::vector<unsigned char>` because it helps users to\r\neasily feed both text and binary buffers into `mbedtls` api without any cast or\r\nconversion.\r\n\r\nsee [configs.hpp](./include/mbedcrypto/configs.hpp)\r\n\r\n\r\n### error handling\r\n`mbedcrypto` objects and functions throw\r\n[`mbedcrypro::exception`](./include/mbedcrypto/exception.hpp) unless they're\r\ntagged by `noexcept` keyword.\r\n```cpp\r\ntry {\r\n  //\r\n  // mbedcrypto codes ...\r\n  //\r\n} catch ( mbedcrypto::exception& cerr ) {\r\n  std::cerr << \"the expanded error message is: \"\r\n      << cerr.what() << std::endl;\r\n  int c_error_code = cerr.code(); // the underlying error code\r\n}\r\n```\r\n\r\nthe structure of `cerr.what()`:\r\n```text\r\n[message, prefix or function name][(error code in hex): [module name] error string]\r\n\r\nex:\r\nmbedtls_md_starts(-0x5100): MD - Bad input parameters to function\r\n - function name: mbedtls_md_starts\r\n - error code: -0x5100\r\n - module name: MD (message digest)\r\n```\r\n\r\nthe low level functions returns a non-zero `int` as an error and are tagged by\r\n`noexcept`:\r\n```cpp\r\nint ret = an_object.a_low_level_method(...);\r\nif ( ret != 0 ) {\r\n  std::cout << \"underlying error code: \"\r\n      << mbedcrypto::mbedtls_error_string(ret) << std::endl;\r\n}\r\n```\r\n\r\n### available algorithms\r\nto list all available (included in build) algorithms:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nauto hashes = installed_hashes(); // returns std::vector<mbedcrypto::hasht_t>\r\nstd::cout << \"supports \" << hashes.size() << \" hash algorithms: \";\r\nfor ( auto h : hashes ) { // print all installed hashes\r\n  // convert type to string\r\n  std::cout << to_string(h) << \" , \";\r\n}\r\n\r\n// similarly\r\nauto paddings = installed_paddings();\r\nauto bmodes   = installed_block_modes();\r\nauto ciphers  = installed_ciphers();\r\nauto pks      = installed_pks();\r\nauto curves   = installed_curves();\r\n\r\n// convert from string to a type\r\nauto htype = from_string<hash_t>(\"sha256\");\r\nif ( htype != hash_t::none ) {\r\n}\r\n```\r\n\r\nto check for availability of a feature:\r\n```cpp\r\n// check by type (enum class)\r\nif ( supports(cipher_t::aes_256_cbc)   &&   supports(pk_t::rsa) ) {\r\n  // do stuff\r\n}\r\n// check by algorithm name\r\nif ( supports_hash(\"sha1\")    &&    supports_pk(\"rsa\") ) {\r\n  // sign a message ...\r\n}\r\n// both upper and lower case are supported\r\nif ( supports_cipher(\"CAMELLIA_128_CBC\") ) {\r\n}\r\n\r\n// to check a single feature\r\nif ( suppurts(features::aes_ni) ) {\r\n  std::cout << \"this system supports AESNI (hardware accelerated AES)\" << std::endl;\r\n}\r\n\r\nif ( supports(features::aead)    &&    supports(cipher_bm::gcm) ) {\r\n  // do GCM authenticated encryption with additional data\r\n}\r\n```\r\n\r\nsee [types.hpp](./include/mbedcrypto/types.hpp)\r\n\r\n\r\n### text-binary conversion\r\nhandy utility to convert binary into (from) text:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nstd::fstream fpng = open_a_png_file(...);\r\nstd::string bin_data; // binary data\r\nfpng >> bin_data;\r\n\r\nauto png_hex = to_hex(bin_data);\r\nauto png_b64 = to_base64(bin_data);\r\n\r\nREQUIRE( from_hex(png_hex) == from_base64(png_b64) );\r\n\r\n// to get the required base64 size\r\nsize_t encode_size = base64::encode_size(bin_data);\r\npng_b64 = base64::encode(bin_data);\r\n\r\nREQUIRE( base64::decode_size(png_b64) == bin_data.size() );\r\n\r\nREQUIRE_THROWS( base64::decode(\"invalid base64 string @#$%#^$\") );\r\n```\r\n\r\nsee [tcodec.hpp](./include/mbedcrypto/tcodec.hpp)\r\n\r\n\r\n### hashes\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\n// by single shot functions\r\nauto hvalue = make_hash(hash_t::sha256, source_data);\r\nstd::cout << to_base64(hvalue) << std::endl;\r\n\r\nauto hmac_value = hmac::make(hash_t::md5, key_data, source_data);\r\n```\r\nor\r\n```cpp\r\nhash h0(hash_t::ripemd160);\r\nhash h1(from_string<hash_t>(\"sha1\"));\r\n\r\nh1.start();\r\nwhile ( ... ) {\r\n  h1.update(read_some_data());\r\n}\r\nauto hvalue = h1.finish();\r\n\r\n// re-use\r\nh1.start();\r\nh1.update(...);\r\nhvalue = h1.finish();\r\n```\r\n\r\nsee [hash.hpp](./include/mbedcrypto/hash.hpp)\r\n\r\n\r\n### ciphers\r\nIf a cipher block mode allows, the `cipher` class automatically breaks input\r\ndata into **chunks** (`cipher::block_size()`) and frees the user from\r\nbreaking/merging of input/output data:\r\n\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\nstd::string source_plain_data = read_from_somewhere();\r\n\r\n// encrypt and decrypt by single-shot functions\r\nauto ciphered_buffer = cipher::encrypt(\r\n    cipher_t::aes_256_cbc,\r\n    padding_t::pkcs7,\r\n    initial_vector_data,  // get iv size from cipher::iv_size()\r\n    key_data,             // get key length in bit by cipher::key_bitlen()\r\n    source_plain_data     // could be in any size because of cbc block mode\r\n    );\r\n\r\nauto decrypted_buffer = cipher::decrypt(\r\n    cipher_t::aes_256_cbc,\r\n    padding_t::pkcs7,\r\n    initial_vector_data,\r\n    key_data,\r\n    ciphered_buffer\r\n    );\r\n\r\nREQUIRE( source_plain_data == decrypted_buffer );\r\n```\r\n\r\nto use [authenticated encryption with associated data (aka\r\naead)](https://en.wikipedia.org/wiki/Authenticated_encryption):\r\n```cpp\r\nstd::string the_additional_data = ...;\r\n\r\nauto encr = cipher::encrypt_aead(\r\n    cipher_t::aes_256_ccm,\r\n    iv_data,\r\n    key_data,\r\n    the_additional_data,\r\n    source_plain_data\r\n    );  ///< returns a std::tuple< computed_tag, encrypted_data >\r\n\r\n\r\nauto decr = cipher::decrypt_aead(\r\n    cipher_t::aes_256_ccm,\r\n    iv_data,\r\n    key_data,\r\n    the_additional_data,\r\n    std::get<1>(encr), // encrypted input\r\n    std::get<0>(encr)  // authentication tag\r\n    );  ///< returns a std::tuple< authentication_status, decrypted_data >\r\n\r\n\r\n  REQUIRE( std::get<0>(decr) == true ); // authenticated?\r\n  REQUIRE( std::get<1>(decr) == source_plain_data );\r\n```\r\n\r\n\r\nor by reusable object:\r\n```cpp\r\n// construct and setup properties\r\ncipher cipdec(cipher_t::aes_256_cbc);\r\ncipdec\r\n  .padding(padding_t::pkcs7)\r\n  .iv(iv_data)\r\n  .key(key_data, cipher::decrypt_mode);\r\n\r\n// by start() / update()s / finish()\r\ncipdec.start();\r\nstd::string decrypted_data;\r\nwhile ( ... ) {\r\n  decrypted_data += cipdec.update(read_some_encrypted_data());\r\n}\r\ndecrypted_data += cipdec.finish();\r\nREQUIRE( source_plain_data == decrypted_data );\r\n\r\n// re-use the object\r\ncipdec.start();\r\ncipdec.update(...); // or multiple updates\r\ncipdec.finish();\r\n\r\n// single shot re-use\r\ndecrypted_data = cipdec.crypt(encrypted_data);\r\n```\r\n\r\nsee [cipher.hpp](./include/mbedcrypto/cipher.hpp)\r\n\r\n\r\n### random byte generator\r\n```cpp\r\nmbedcrypto::random rnd_generator;\r\nauto random_data1 = rnd_generator.make(256); // in bytes\r\nauto random_data2 = rnd_generator.make(32);  // in bytes\r\n//\r\n```\r\n\r\nsee [random.hpp](./include/mbedcrypto/random.hpp)\r\n\r\n\r\n### pks\r\nloading or exporting keys:\r\n```cpp\r\nusing namespace mbedcrypto;\r\n\r\npki pri;\r\npri.parse_key(private_key_data, optional_password);\r\n// or load from by a file name\r\n// pri.load_key(\"private_key.pem\");\r\n\r\npki pub;\r\npub.parse_public_key(public_key_data);\r\n\r\n// [optional] check matching public/private pair\r\nREQUIRE( pki::check_pair(pub, pri) == true );\r\n\r\n// export keys\r\nif ( supports(features::pk_export) ) {\r\n    auto der_data = pri.export_key(pki::der_format);\r\n    // write or send\r\n}\r\n\r\n// key generation\r\nif ( supports(features::rsa_keygen) ) {\r\n    pki rg(pk_t::rsa);\r\n    rg.rsa_generate_key(2048);\r\n    // do stuff\r\n}\r\n```\r\n\r\nsign and verify:\r\n```cpp\r\n// signature & verification\r\nstd::string message = read_message_from_somewhere();\r\nauto signature      = pri.sign(message, hash_t::sha256);\r\nREQUIRE( pub.verify(signature, message, hash_t::sha256);\r\n```\r\n\r\nto encrypt and decrypt by pki:\r\n```cpp\r\nconst auto hvalue = hash::make(hash_t::sha256, message);\r\n\r\npki pub;\r\npub.parse_public_key(public_key_data);\r\n\r\nauto encv = pub.encrypt(message, hash_t::sha256);\r\n// or\r\n// auto encv = pub.encrypt(hvalue);\r\n\r\npki pri;\r\npri.parse_key(private_key_data);\r\nauto decv = pri.decrypt(encv);\r\nREQUIRE( decv == hvalue );\r\n```\r\n\r\nsee [pki.hpp](./include/mbedcrypto/pki.hpp)\r\n\r\n---\r\n\r\n## tests\r\nsamples and unit tests are available under [tests/tdd](./tests/tdd/) folder.\r\n\r\nthe test application has been built by\r\n[catch](https://github.com/philsquared/Catch):\r\n```bash\r\n$xbin/> ./tests -t\r\nAll available tags:\r\n   1  [base64]\r\n   2  [cipher]\r\n   1  [exception]\r\n   1  [hash]\r\n   1  [hex]\r\n   2  [pki]\r\n   1  [random]\r\n   4  [types]\r\n8 tags\r\n```\r\n\r\n---\r\n\r\n## notes\r\n\r\n### cryptography\r\n[cryptography](https://en.wikipedia.org/wiki/Outline_of_cryptography) is both\r\ncomplex and complicated, it requires a vast knowledge of mathematics, concepts,\r\nprinciples, algorithms, standards, conventions, continuous investigation of\r\nattacks, ...\r\n\r\n> As cryptography is mostly used to protect sensitive data, writing a library\r\n> for it is a daunting task and difficult by any factor.\r\n\r\nSo instead of writing a library from scratch, `mbedcrypto` stands on the\r\nshoulders of giants, `mbedtls` is this case.\r\n\r\n### mbedtls\r\nAlthough [mbedtls](https://github.com/ARMmbed/mbedtls) is mostly a `TLS/SSL`\r\nlibrary for embedded devices, it has already implemented the most famous and\r\nwidely used cryptographic algorithms and actively developed and maintained.\r\n\r\nArguably `mbedtls` has cleaner code than `openssl`, it's easier to read, use\r\nand maintain, and it has been designed for efficiency and portability from\r\nscratch (for embedded devices), and has many advantages over `openssl` like as\r\nreadability, size, compiling and setup, … to name a few.\r\n\r\n\r\n## disclaimer\r\n\r\n- implementing an easy-to-use, lightweight and portable `c++` library for\r\ncryptography are the main purpose of `mbedcrypto`.\r\n- there are many more algorithms in cryptographic libraries, the focus of\r\n`mbedcrypto` is on the most important or widely used algorithms, tries to be\r\nsimple and not to bloat your application.\r\n- as mentioned in [notes](#notes), the cryptography can be divided into several\r\nareas of study and best practices, I'm not a guru nor a specialist in this\r\nfield.\r\n\r\n\r\n> If you have any ideas, critiques, suggestions or whatever you want to call\r\n> it, please open an issue. I'll be happy to hear from you what you'd see in\r\n> this lib. I think about all suggestions, and I try to add those that make\r\n> sense.\r\n\r\n\r\n## license\r\nDistributed under the MIT license. Copyright (c) 2016, Amir Zamani.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}